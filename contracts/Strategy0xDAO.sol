// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

import "./StrategyAuthorized.sol";
import "./interfaces/uniswap.sol";
import "./interfaces/IRedirectVault.sol";
import "./interfaces/IStrategy.sol";

import "./interfaces/ISolidlyRouter01.sol";
import "./interfaces/oxdao/IMultiRewards.sol";
import "./interfaces/oxdao/IOxLens.sol";
import "./interfaces/oxdao/IOxPool.sol";



/**
 * @dev Implementation of a strategy to get yields from farming LP Pools in SpookySwap.
 * SpookySwap is an automated market maker (“AMM”) that allows two tokens to be exchanged on Fantom's Opera Network.
 *
 * This strategy deposits whatever funds it receives from the vault into the selected masterChef pool.
 * rewards from providing liquidity are farmed every few minutes, sold and split 50/50.
 * The corresponding pair of assets are bought and more liquidity is added to the masterChef pool.
 *
 * Expect the amount of LP tokens you have to grow over time while you have assets deposit
 */
contract Strategy0xDAO is IStrategy, StrategyAuthorized, Pausable {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    /**
     * @dev Tokens Used:
     * {wftm} - Required for liquidity routing when doing swaps.
     * {rewardToken} - Token generated by staking our funds.
     * {lpPair} - LP Token that the strategy maximizes.
     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens.
     */
    address public wftm = address(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83);
    address public rewardToken0 =
        address(0xc5A9848b9d145965d821AaeC8fA32aaEE026492d); //0XDAO
    address public rewardToken1 = 
        address(0x888EF71766ca594DED1F0FA3AE64eD2941740A20); // solid
    uint8 public rewardTokens = 2;
    address public lpPair;
    address public lpToken0;
    address public lpToken1;
    IBaseV1Pair pair;

    mapping(uint8 => bool) public isEmitting;
    mapping(address => address) tokenRouter;

    /**
     * @dev Third Party Contracts:
     * {router} - the router for target DEX
     * {masterChef} - masterChef contract
     * {poolId} - masterChef pool id
     */
    address public constant spookyRouter =
        address(0xF491e7B69E4244ad4002BC14e878a34207E38c29);
    address public constant spiritRouter =
        address(0x16327E3FbDaCA3bcF7E38F5Af2599D2DDc33aE52);

    address[] private pools = new address[](1);
    IOxLens public constant oxLens = IOxLens(0xDA00137c79B30bfE06d04733349d98Cf06320e69);
    address public oxPoolAddress;
    address public stakingAddress;
    address public constant solidlyRouter = 0xa38cd27185a464914D3046f0AB9d43356B34829D;


    /**
     * @dev Associated Contracts:
     * {vault} - Address of the vault that controls the strategy's funds.
     */
    address public vault;

    /**
     * @dev Distribution of fees earned. This allocations relative to the % implemented on
     * Current implementation separates 5% for fees. Can be changed through the constructor
     * Inputs in constructor should be ratios between the Fee and Max Fee, divisble into percents by 10000
     *
     * {callFee} - Percent of the totalFee reserved for the harvester (1000 = 10% of total fee: 0.5% by default)
     * {treasuryFee} - Percent of the totalFee taken by maintainers of the software (9000 = 90% of total fee: 4.5% by default)
     * {securityFee} - Fee taxed when a user withdraws funds. Taken to prevent flash deposit/harvest attacks.
     * These funds are redistributed to stakers in the pool.
     *
     * {totalFee} - divided by 10,000 to determine the % fee. Set to 5% by default and
     * lowered as necessary to provide users with the most competitive APY.
     *
     * {MAX_FEE} - Maximum fee allowed by the strategy. Hard-capped at 5%.
     * {PERCENT_DIVISOR} - Constant used to safely calculate the correct percentages.
     */
    // uint public callFee = 1000;
    // uint public treasuryFee = 9000;
    // uint public securityFee = 10;
    // uint public totalFee = 450;
    // uint constant public MAX_FEE = 500;
    uint256 public constant PERCENT_DIVISOR = 10000;

    /**
     * @dev Routes we take to swap tokens using PanrewardTokenSwap.
     * {rewardTokenToWftmRoute} - Route we take to get from {rewardToken} into {wftm}.
     * {rewardTokenToLp0Route} - Route we take to get from {rewardToken} into {lpToken0}.
     * {rewardTokenToLp1Route} - Route we take to get from {rewardToken} into {lpToken1}.
     */
    address[] public rewardToken0ToWftmRoute = [rewardToken0, wftm];
    address[] public rewardToken1ToWftmRoute = [rewardToken1, wftm];
    address[] public wftmToLp0Route;
    address[] public wftmToLp1Route;

    /**
     * {StratHarvest} Event that is fired each time someone harvests the strat.
     * {TotalFeeUpdated} Event that is fired each time the total fee is updated.
     * {CallFeeUpdated} Event that is fired each time the call fee is updated.
     */
    event TotalFeeUpdated(uint256 newFee);
    event CallFeeUpdated(uint256 newCallFee, uint256 newTreasuryFee);

    /**
     * @dev Initializes the strategy. Sets parameters, saves routes, and gives allowances.
     * @notice see documentation for each variable above its respective declaration.
     */
    constructor(
        address _vault,
        address _lpPair
    ) {



        lpPair = _lpPair;
        vault = _vault;
        pair = IBaseV1Pair(_lpPair);
        (,,,,,  lpToken0,  lpToken1) = pair.metadata();

        if (lpToken0 != wftm) {
            wftmToLp0Route = [wftm, lpToken0];
        }

        if (lpToken1 != wftm) {
            wftmToLp1Route = [wftm, lpToken1];
        }

        /*
        tokenRouter[lpToken0] = spookyRouter;
        tokenRouter[lpToken1] = spookyRouter;
        tokenRouter[rewardToken0] = spiritRouter;
        */
        
        isEmitting[0] = true;
        isEmitting[1] = true;

        pools[0] = lpPair;

        oxPoolAddress = oxLens.oxPoolBySolidPool(lpPair);
        stakingAddress = IOxPool(oxPoolAddress).stakingAddress();

        giveAllowances();
    }

    modifier onlyVault() {
        require(vault == _msgSender(), "!vault");
        _;
    }

    function governance() public view override returns (address) {
        return IRedirectVault(vault).governance();
    }

    /**
     * @dev Function that puts the funds to work.
     * It gets called whenever someone deposits in the strategy's vault contract.
     * It deposits {lpPair} in the masterChef to farm {rewardToken}
     */
    function deposit() public whenNotPaused {
        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));

        if (pairBal > 0) {
            // Deposit 
            IOxPool(oxPoolAddress).depositLp(pairBal);
            // Stake
            IMultiRewards(stakingAddress).stake(pairBal);
        }
    }

    /**
     * @dev Withdraws funds and sents them back to the vault.
     * It withdraws {lpPair} from the masterChef.
     * The available {lpPair} minus fees is returned to the vault.
     */
    function withdraw(uint256 _amount) external onlyVault {
        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));

        if (pairBal < _amount) {
            IMultiRewards(stakingAddress).withdraw(_amount.sub(pairBal));
            IOxPool(oxPoolAddress).withdrawLp(_amount.sub(pairBal));
            pairBal = IERC20(lpPair).balanceOf(address(this));
        }

        if (pairBal > _amount) {
            pairBal = _amount;
        }
        IERC20(lpPair).safeTransfer(vault, pairBal);
    }

    /**
     * @dev Core function of the strat, in charge of collecting and re-investing rewards.
     * 1. It claims rewards from the masterChef.
     * 2. It charges the system fees to simplify the split.
     * 3. It swaps the {rewardToken} token for {lpToken0} & {lpToken1}
     * 4. Adds more liquidity to the pool.
     * 5. It deposits the new LP tokens.
     */
    function claim(address to)
        external
        onlyVault
        whenNotPaused
        returns (MultiRewards[] memory _rewards)
    {
        // require(!Address.isContract(msg.sender), "!contract");
        IMultiRewards(stakingAddress).getReward();

        uint256 balanceReward0 = IERC20(rewardToken0).balanceOf(address(this));
        if (balanceReward0 > 0) {
            IERC20(rewardToken0).transfer(to, balanceReward0);
        }

        uint256 balanceReward1 = IERC20(rewardToken1).balanceOf(address(this));
        if (balanceReward1 > 0) {
            IERC20(rewardToken1).transfer(to, balanceReward1);
        }
        _rewards = new MultiRewards[](2);
        _rewards[0] = MultiRewards(rewardToken0, balanceReward0);
        _rewards[1] = MultiRewards(rewardToken1, balanceReward1);


    }

    /**
     * @dev Function to calculate the total underlaying {lpPair} held by the strat.
     * It takes into account both the funds in hand, as the funds allocated in the masterChef.
     */
    function balanceOf() public view returns (uint256) {
        return balanceOfLpPair().add(balanceOfPool());
    }

    /**
     * @dev It calculates how much {lpPair} the contract holds.
     */
    function balanceOfLpPair() public view returns (uint256) {
        return IERC20(lpPair).balanceOf(address(this));
    }

    /**
     * @dev It calculates how much {lpPair} the strategy has allocated in the masterChef
     */
    function balanceOfPool() public view returns (uint256) {
        return IMultiRewards(stakingAddress).balanceOf(address(this));

    }

    /**
     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the
     * vault, ready to be migrated to the new strat.
     */
    function retireStrat() external onlyVault {
        uint256 deposited = balanceOfPool();

        IMultiRewards(stakingAddress).withdraw(deposited);
        IOxPool(oxPoolAddress).withdrawLp(deposited);

        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));
        IERC20(lpPair).transfer(vault, pairBal);
    }

    /**
     * @dev Pauses deposits. Withdraws all funds from the masterChef, leaving rewards behind
     */
    function panic() public onlyAuthorized {
        pause();
        uint256 deposited = balanceOfPool();
        IMultiRewards(stakingAddress).withdraw(deposited);
        IOxPool(oxPoolAddress).withdrawLp(deposited);
    }

    /**
     * @dev Pauses the strat.
     */
    function pause() public onlyAuthorized {
        _pause();
        removeAllowances();
    }

    /**
     * @dev Unpauses the strat.
     */
    function unpause() external onlyAuthorized {
        _unpause();

        giveAllowances();

        deposit();
    }

    function giveAllowances() internal {
        IERC20(lpPair).safeApprove(address(oxPoolAddress), type(uint256).max);
        IERC20(rewardToken0).safeApprove(solidlyRouter, type(uint256).max);
        IERC20(wftm).safeApprove(spookyRouter, type(uint256).max);

        IERC20(lpToken0).safeApprove(spookyRouter, 0);
        IERC20(lpToken0).safeApprove(spookyRouter, type(uint256).max);

        IERC20(lpToken1).safeApprove(spookyRouter, 0);
        IERC20(lpToken1).safeApprove(spookyRouter, type(uint256).max);
    }

    function removeAllowances() internal {
        IERC20(lpPair).safeApprove(address(oxPoolAddress), 0);
        IERC20(rewardToken0).safeApprove(solidlyRouter, 0);
        IERC20(wftm).safeApprove(spookyRouter, 0);
        IERC20(lpToken0).safeApprove(spookyRouter, 0);
        IERC20(lpToken1).safeApprove(spookyRouter, 0);
    }

    function emittance(uint8 _id, bool _status)
        external
        onlyAuthorized
        returns (bool)
    {
        isEmitting[_id] = _status;
        return true;
    }

    function addRewardToken(address _token, address _router)
        external
        onlyAuthorized
        returns (bool)
    {
        rewardToken1 = _token;
        tokenRouter[rewardToken1] = _router;
        IERC20(rewardToken1).safeApprove(
            tokenRouter[rewardToken1],
            type(uint256).max
        );
        rewardToken1ToWftmRoute = [rewardToken1, wftm];
        isEmitting[1] = true;
        rewardTokens = 2;
        return true;
    }
}
